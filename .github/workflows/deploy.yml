name: deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      build_api:
        description: 'Build API image'
        required: false
        type: boolean
        default: true
      build_client:
        description: 'Build Client image'
        required: false
        type: boolean
        default: true
      build_ingest:
        description: 'Build Ingest image'
        required: false
        type: boolean
        default: true
      build_backup:
        description: 'Build Backup image'
        required: false
        type: boolean
        default: true

permissions:
  contents: read
  packages: write

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  STACK: eventmap
  OWNER: ${{ github.repository_owner }}
  REPO: ${{ github.event.repository.name }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # --- lower case
      - name: set lower case owner name
        run: |
          echo "OWNER_LC=${OWNER,,}" >>${GITHUB_ENV}
          echo "REPO_LC=${REPO,,}" >>${GITHUB_ENV}

      # ---- Build & push images to GHCR ----
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USER }}
          password: ${{ secrets.GHCR_PAT }}

      - name: Build & push API
        if: github.event_name == 'push' || inputs.build_api == true
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_on: error
          command: |
            docker buildx build \
              --push \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-api:latest \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-api:${{ github.sha }} \
              --provenance=false \
              ./api

      - name: Build & push Ingest
        if: github.event_name == 'push' || inputs.build_ingest == true
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_on: error
          command: |
            docker buildx build \
              --push \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-events-ingest:latest \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-events-ingest:${{ github.sha }} \
              --provenance=false \
              ./infra/ingest

      - name: Build & push Backup
        if: github.event_name == 'push' || inputs.build_backup == true
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_on: error
          command: |
            docker buildx build \
              --push \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-db-backup:latest \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-db-backup:${{ github.sha }} \
              --provenance=false \
              ./infra/backup

      - name: Build & push Client (inject prod API base URL)
        if: github.event_name == 'push' || inputs.build_client == true
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 10
          max_attempts: 3
          retry_on: error
          command: |
            docker buildx build \
              --push \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-client:latest \
              --tag ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-client:${{ github.sha }} \
              --build-arg VITE_API_BASE_URL=/api \
              --build-arg VITE_GOOGLE_MAPS_KEY=${{ secrets.GOOGLE_MAPS_KEY }} \
              --build-arg VITE_FIREBASE_API_KEY=${{ secrets.FIREBASE_API_KEY }} \
              --build-arg VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.FIREBASE_PROJECT_ID }}.firebaseapp.com \
              --build-arg VITE_FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }} \
              --build-arg VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.FIREBASE_PROJECT_ID }}.firebasestorage.app \
              --build-arg VITE_FIREBASE_APP_ID=${{ secrets.FIREBASE_APP_ID }} \
              --build-arg VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.FIREBASE_MESSAGING_SENDER_ID }} \
              --provenance=false \
              ./client

      # ---- Copy stack + db/ to droplet (first time or whenever they change) ----
      - name: Upload stack.yml and db/
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ vars.DO_SSH_HOST }}
          username: ${{ vars.DO_SSH_USER }}
          key: ${{ secrets.DO_SSH_KEY }}
          passphrase: ${{ secrets.DO_SSH_PASSPHRASE }}
          source: "stack.yml,db/*,infra/*"
          target: "/root/deploy/"

      # ---- Deploy on droplet ----
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ vars.DO_SSH_HOST }}
          username: ${{ vars.DO_SSH_USER }}
          key: ${{ secrets.DO_SSH_KEY }}
          passphrase: ${{ secrets.DO_SSH_PASSPHRASE }}
          script: |
            set -euo pipefail

            echo "[*] Logging in to GHCR on droplet..."
            docker login ghcr.io -u ${{ secrets.GHCR_USER }} -p ${{ secrets.GHCR_PAT }}

            echo "[*] Preparing deploy directory and .env ..."
            mkdir -p /root/deploy
            cat >/root/deploy/.env <<'EOF'
            BACKEND_PORT=${{ vars.BACKEND_PORT }}
            DB_PORT=${{ vars.DB_PORT }}
            DB_NAME=${{ vars.DB_NAME }}
            DB_USER=${{ vars.DB_USER }}
            REDIS_PORT=${{ vars.REDIS_PORT }}
            VITE_FIREBASE_API_KEY=${{ secrets.FIREBASE_API_KEY }}
            VITE_FIREBASE_AUTH_DOMAIN=${{ secrets.FIREBASE_PROJECT_ID }}.firebaseapp.com
            VITE_FIREBASE_PROJECT_ID=${{ secrets.FIREBASE_PROJECT_ID }}
            VITE_FIREBASE_STORAGE_BUCKET=${{ secrets.FIREBASE_PROJECT_ID }}.firebasestorage.app
            VITE_FIREBASE_APP_ID=${{ secrets.FIREBASE_APP_ID }}
            VITE_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.FIREBASE_MESSAGING_SENDER_ID }}
            DOMAIN=${{ secrets.DOMAIN }}
            EMAIL=${{ secrets.EMAIL }}
            DO_SPACES_BUCKET=${{ secrets.DO_SPACES_BUCKET }}
            DO_SPACES_ENDPOINT=${{ secrets.DO_SPACES_ENDPOINT }}
            DO_SPACES_ACCESS_KEY=${{ secrets.DO_SPACES_ACCESS_KEY }}
            DO_SPACES_SECRET_KEY=${{ secrets.DO_SPACES_SECRET_KEY }}
            GHCR_USER=${{ secrets.GHCR_USER }}
            GHCR_PAT=${{ secrets.GHCR_PAT }}
            EOF

            echo "[*] Ensuring Swarm is active..."
            if ! docker info --format '{{.Swarm.LocalNodeState}}' | grep -q 'active'; then
              docker swarm init
            fi

            echo "[*] Ensuring DO Volume mountpoint exists and permissions are correct..."
            mkdir -p /mnt/pgdata/postgres-data/pgdata
            mkdir -p /mnt/pgdata/redis-data

            chown -R 70:70 /mnt/pgdata/postgres-data/pgdata || true
            chmod 700 /mnt/pgdata/postgres-data/pgdata || true

            chown -R 999:999 /mnt/pgdata/redis-data || true
            chmod 777 /mnt/pgdata/redis-data || true

            echo "[*] Ensuring pg_password secret exists..."
            if ! docker secret ls | awk '{print $2}' | grep -qx 'pg_password'; then
              docker secret create pg_password /root/pg_password.txt
            else
              echo "pg_password already present."
            fi

            if ! docker secret ls | awk '{print $2}' | grep -qx 'redis_password'; then
              docker secret create redis_password /root/redis_password.txt
            else
              echo "redis_password already present."
            fi

            echo "[*] Pulling freshly built images by SHA..."
            
            # Only pull images that were actually built
            if [[ "${{ github.event_name }}" == "push" ]] || [[ "${{ inputs.build_api }}" == "true" ]]; then
              docker pull ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-api:${{ github.sha }}
            fi
            
            if [[ "${{ github.event_name }}" == "push" ]] || [[ "${{ inputs.build_client }}" == "true" ]]; then
              docker pull ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-client:${{ github.sha }}
            fi
            
            if [[ "${{ github.event_name }}" == "push" ]] || [[ "${{ inputs.build_ingest }}" == "true" ]]; then
              docker pull ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-events-ingest:${{ github.sha }}
            fi
            
            if [[ "${{ github.event_name }}" == "push" ]] || [[ "${{ inputs.build_backup }}" == "true" ]]; then
              docker pull ${{ env.REGISTRY }}/${{ secrets.GHCR_USER }}/${{ env.REPO_LC }}-db-backup:${{ github.sha }}
            fi
            echo "[*] Deploying/Updating stack: ${{ env.STACK }}"

            set -a
            . /root/deploy/.env
            set +a
            docker stack deploy -c /root/deploy/stack.yml ${{ env.STACK }} --with-registry-auth

            echo "[✓] Done. Current services:"
            docker service ls

            echo "[*] Prune unused or stopped containers/networks/images/volumes ... "
            docker system prune -a -f

            echo "[✓] Disk usage after prune:"
            docker system df

